<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Flexbox Blueprint</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #18181b;
            color: #f4f4f5;
            margin: 0;
            padding: 40px 20px;
        }

        h1 { margin-top: 0; font-size: 28px; margin-bottom: 5px; }
        p { color: #a1a1aa; margin-bottom: 20px; }

        .instruction {
            background: #4f46e5;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            background: #27272a;
            padding: 20px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group { display: flex; flex-direction: column; gap: 8px; }

        label { font-size: 14px; font-weight: 600; color: #d4d4d8; }

        select {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #3f3f46;
            background: #18181b;
            color: #f4f4f5;
            font-size: 15px;
            outline: none;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        select:focus { border-color: #6366f1; }

        .canvas-container {
            position: relative;
        }

        canvas {
            background: #1e1e24; /* Slightly darker for blueprint feel */
            border: 3px solid #3f3f46;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>

    <h1>Flexbox Blueprint Simulator</h1>
    <p>Watch the dimension lines calculate the layout math in real-time.</p>
    
    <div class="instruction">ðŸ‘‡ Try 'space-between' or 'space-evenly' to see the math divide! ðŸ‘‡</div>

    <div class="controls">
        <div class="control-group">
            <label for="flexDirection">flex-direction</label>
            <select id="flexDirection">
                <option value="row">row</option>
                <option value="row-reverse">row-reverse</option>
                <option value="column">column</option>
                <option value="column-reverse">column-reverse</option>
            </select>
        </div>

        <div class="control-group">
            <label for="justifyContent">justify-content</label>
            <select id="justifyContent">
                <option value="flex-start">flex-start</option>
                <option value="flex-end">flex-end</option>
                <option value="center">center</option>
                <option value="space-between">space-between</option>
                <option value="space-around">space-around</option>
                <option value="space-evenly">space-evenly</option>
            </select>
        </div>

        <div class="control-group">
            <label for="alignItems">align-items</label>
            <select id="alignItems">
                <option value="stretch">stretch</option>
                <option value="flex-start">flex-start</option>
                <option value="flex-end">flex-end</option>
                <option value="center">center</option>
            </select>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="flexCanvas" width="800" height="450"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('flexCanvas');
        const ctx = canvas.getContext('2d');

        const dirSelect = document.getElementById('flexDirection');
        const justifySelect = document.getElementById('justifyContent');
        const alignSelect = document.getElementById('alignItems');

        const items = [
            { id: '1', baseW: 120, baseH: 80, color: '#f87171', x: 0, y: 0, w: 120, h: 80, tx: 0, ty: 0, tw: 120, th: 80 },
            { id: '2', baseW: 100, baseH: 140, color: '#60a5fa', x: 0, y: 0, w: 100, h: 140, tx: 0, ty: 0, tw: 100, th: 140 },
            { id: '3', baseW: 160, baseH: 100, color: '#34d399', x: 0, y: 0, w: 160, h: 100, tx: 0, ty: 0, tw: 160, th: 100 }
        ];

        let currentDirection = 'row';

        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        function calculateLayout() {
            const direction = dirSelect.value;
            const justify = justifySelect.value;
            const align = alignSelect.value;
            currentDirection = direction;

            const isRow = direction.includes('row');
            const isReverse = direction.includes('reverse');

            const mainDim = isRow ? canvas.width : canvas.height;
            const crossDim = isRow ? canvas.height : canvas.width;

            let totalMainSize = 0;
            items.forEach(item => { totalMainSize += isRow ? item.baseW : item.baseH; });

            let remainingSpace = mainDim - totalMainSize;
            let startPos = 0;
            let gap = 0;
            const n = items.length;

            if (justify === 'flex-start') { startPos = 0; } 
            else if (justify === 'flex-end') { startPos = remainingSpace; } 
            else if (justify === 'center') { startPos = remainingSpace / 2; } 
            else if (justify === 'space-between') { gap = remainingSpace / (n - 1); } 
            else if (justify === 'space-around') { gap = remainingSpace / n; startPos = gap / 2; } 
            else if (justify === 'space-evenly') { gap = remainingSpace / (n + 1); startPos = gap; }

            let currentMainPos = startPos;
            const order = isReverse ? [2, 1, 0] : [0, 1, 2];

            order.forEach(index => {
                const item = items[index];
                const itemMainSize = isRow ? item.baseW : item.baseH;
                const itemCrossSize = isRow ? item.baseH : item.baseW;

                let crossPos = 0;
                let actualCrossSize = itemCrossSize;

                if (align === 'flex-end') { crossPos = crossDim - itemCrossSize; } 
                else if (align === 'center') { crossPos = (crossDim - itemCrossSize) / 2; } 
                else if (align === 'stretch') { actualCrossSize = crossDim; }

                let targetX = isRow ? currentMainPos : crossPos;
                let targetY = isRow ? crossPos : currentMainPos;
                let targetW = isRow ? itemMainSize : actualCrossSize;
                let targetH = isRow ? actualCrossSize : itemMainSize;

                if (isReverse && isRow) { targetX = canvas.width - currentMainPos - targetW; } 
                else if (isReverse && !isRow) { targetY = canvas.height - currentMainPos - targetH; }

                item.tx = targetX; item.ty = targetY; item.tw = targetW; item.th = targetH;
                currentMainPos += itemMainSize + gap;
            });
        }

        function drawGrid() {
            ctx.strokeStyle = '#27272a';
            ctx.lineWidth = 1;
            for(let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            }
            for(let i = 0; i < canvas.height; i += 40) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke();
            }
        }

        function drawDimensionArrow(x1, y1, x2, y2, text) {
            ctx.strokeStyle = '#fbbf24'; // Amber blueprint color
            ctx.lineWidth = 2;
            
            // Draw main line
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();

            // Draw end ticks
            const tick = 6;
            if (y1 === y2) { // Horizontal line
                ctx.beginPath(); ctx.moveTo(x1, y1 - tick); ctx.lineTo(x1, y1 + tick); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x2, y2 - tick); ctx.lineTo(x2, y2 + tick); ctx.stroke();
            } else { // Vertical line
                ctx.beginPath(); ctx.moveTo(x1 - tick, y1); ctx.lineTo(x1 + tick, y1); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x2 - tick, y2); ctx.lineTo(x2 + tick, y2); ctx.stroke();
            }

            // Draw Text with background
            const cx = (x1 + x2) / 2;
            const cy = (y1 + y2) / 2;
            
            ctx.font = 'bold 13px Consolas, monospace';
            const metrics = ctx.measureText(text);
            const pad = 6;
            
            ctx.fillStyle = '#1e1e24'; // Match canvas bg
            ctx.fillRect(cx - metrics.width/2 - pad, cy - 10, metrics.width + pad*2, 20);
            
            ctx.fillStyle = '#fbbf24';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, cx, cy);
        }

        function drawBlueprintDimensions() {
            const isRow = currentDirection.includes('row');
            // Sort items by physical position on the screen to find the gaps between them
            const sorted = [...items].sort((a, b) => isRow ? a.x - b.x : a.y - b.y);
            
            const midY = canvas.height / 2;
            const midX = canvas.width / 2;

            // 1. Start Space (before the first item)
            let startSpace = isRow ? sorted[0].x : sorted[0].y;
            if (startSpace > 2) { // Only draw if there's enough room
                if (isRow) drawDimensionArrow(0, midY, startSpace, midY, `${Math.round(startSpace)}px`);
                else drawDimensionArrow(midX, 0, midX, startSpace, `${Math.round(startSpace)}px`);
            }

            // 2. The Gaps (between items)
            for (let i = 0; i < sorted.length - 1; i++) {
                let endOfCurrent = isRow ? sorted[i].x + sorted[i].w : sorted[i].y + sorted[i].h;
                let startOfNext = isRow ? sorted[i+1].x : sorted[i+1].y;
                let gap = startOfNext - endOfCurrent;
                
                if (gap > 2) {
                    if (isRow) drawDimensionArrow(endOfCurrent, midY, startOfNext, midY, `${Math.round(gap)}px`);
                    else drawDimensionArrow(midX, endOfCurrent, midX, startOfNext, `${Math.round(gap)}px`);
                }
            }

            // 3. End Space (after the last item)
            let lastItem = sorted[sorted.length - 1];
            let endSpace = isRow ? canvas.width - (lastItem.x + lastItem.w) : canvas.height - (lastItem.y + lastItem.h);
            if (endSpace > 2) {
                let start = isRow ? lastItem.x + lastItem.w : lastItem.y + lastItem.h;
                let end = isRow ? canvas.width : canvas.height;
                if (isRow) drawDimensionArrow(start, midY, end, midY, `${Math.round(endSpace)}px`);
                else drawDimensionArrow(midX, start, midX, end, `${Math.round(endSpace)}px`);
            }

            // 4. Equation Overlay (Bottom Left)
            const totalItemSize = isRow ? 380 : 320; // Hardcoded base sizes for simplicity
            const containerSize = isRow ? canvas.width : canvas.height;
            const remaining = containerSize - totalItemSize;
            
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(10, canvas.height - 35, 360, 25);
            ctx.fillStyle = '#a1a1aa';
            ctx.font = '13px Consolas, monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Free Space = ${containerSize}px - ${totalItemSize}px = ${remaining}px`, 20, canvas.height - 22);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();

            items.forEach(item => {
                // Lerp towards target
                item.x = lerp(item.x, item.tx, 0.1);
                item.y = lerp(item.y, item.ty, 0.1);
                item.w = lerp(item.w, item.tw, 0.1);
                item.h = lerp(item.h, item.th, 0.1);

                // Draw Box
                ctx.fillStyle = item.color;
                if (ctx.roundRect) {
                    ctx.beginPath(); ctx.roundRect(item.x, item.y, item.w, item.h, 6); ctx.fill();
                } else {
                    ctx.fillRect(item.x, item.y, item.w, item.h);
                }

                // Draw Text inside Item
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Item ID
                ctx.fillStyle = '#18181b';
                ctx.font = 'bold 20px Segoe UI';
                ctx.fillText(`Item ${item.id}`, item.x + item.w / 2, item.y + item.h / 2 - 12);
                
                // Item Dimensions
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.font = '13px Consolas, monospace';
                ctx.fillText(`${Math.round(item.w)} Ã— ${Math.round(item.h)}`, item.x + item.w / 2, item.y + item.h / 2 + 12);
            });

            // Draw the gap and spacing math lines over everything
            drawBlueprintDimensions();

            requestAnimationFrame(animate);
        }

        dirSelect.addEventListener('change', calculateLayout);
        justifySelect.addEventListener('change', calculateLayout);
        alignSelect.addEventListener('change', calculateLayout);

        calculateLayout();
        items.forEach(item => { item.x = item.tx; item.y = item.ty; item.w = item.tw; item.h = item.th; });
        animate();
    </script>
</body>
</html>